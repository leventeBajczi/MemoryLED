/* Generated by YAKINDU Statechart Tools for Arduino v0.8.0 */

#ifndef MEMORYLEDCONNECTOR_H
#define MEMORYLEDCONNECTOR_H

#include <Arduino.h>
#include "../src-gen/HardwareConnector.h"
#include "../src-gen/Memoryled.h"

class CustomHandler : public Memoryled::SCI_LED_OCB
{

	public:
			int lights[5];
			void turnOff(){
				for(int i = 8; i <= 12; i++) {
				        digitalWrite(i, LOW);
				}
			}

			void start(){
				digitalWrite(10, HIGH);
				delay(75);
				digitalWrite(10, LOW);
				for(int i = 0; i < 25; i++) {
					digitalWrite(10, HIGH);
					delay(1);
					digitalWrite(10, LOW);
					digitalWrite(9, HIGH);
					delay(1);
					digitalWrite(9, LOW);
					digitalWrite(11, HIGH);
					delay(1);
					digitalWrite(11, LOW);
				}

				for(int i = 0; i < 25; i++) {
					for(int n = 8; n <= 12; n++) {
						digitalWrite(n, HIGH);
						delay(1);
						digitalWrite(n, LOW);
					}
				}
			}

			void blinkRandomly(sc_integer curLevel){
				randomSeed(analogRead(28));
				lights[curLevel]=random(1, 6);
				for(int i = 0; i <= curLevel; i++) {
					digitalWrite(lights[i]+7, HIGH);
					delay(100);
					digitalWrite(lights[i]+7, LOW);
					delay(150);
				}
			}

			void celebrate()
			{
				 //sorfény
				for(int i = 0; i < 5; i++) {
					for(int n = 8; n <= 12; n++) {
						digitalWrite(n, HIGH);
						delay(100);
						digitalWrite(n, LOW);
						delay(1);
					}
				}

				//páros-páratlan
				for(int i = 0; i < 5; i++) {
					for(int n = 0; n < 100; n++) {
						digitalWrite(9, HIGH);
						delay(1);
						digitalWrite(9, LOW);
						digitalWrite(11, HIGH);
						delay(1);
						digitalWrite(11, LOW);
					}

					for(int n = 0; n < 100; n++) {
						digitalWrite(8, HIGH);
						delay(1);
						digitalWrite(8, LOW);
						digitalWrite(10, HIGH);
						delay(1);
						digitalWrite(10, LOW);
						digitalWrite(12, HIGH);
						delay(1);
						digitalWrite(12, LOW);
					}
				}

				//oda-vissza
				for(int i = 0; i < 3; i++) {
					int tmp;
					for(int n = 12; n >= 8; n--) {
						for(int m = 0; m < 100; m++) {
							tmp = n;
							while(tmp >= 8) {
								digitalWrite(tmp, HIGH);
								delay(1);
								digitalWrite(tmp, LOW);
								tmp--;
							}
						}
					}
					delay(50);
					for(int n = 8; n <= 12; n++) {
						for(int m = 0; m < 100; m++) {
							tmp = n;
							while(tmp <= 12) {
								digitalWrite(tmp, HIGH);
								delay(1);
								digitalWrite(tmp, LOW);
								tmp++;
							}
						}
					}
					delay(50);
				}

				//páros-páratlan
				for(int i = 0; i < 5; i++) {
					for(int n = 0; n < 100; n++) {
						digitalWrite(9, HIGH);
						delay(1);
						digitalWrite(9, LOW);
						digitalWrite(11, HIGH);
						delay(1);
						digitalWrite(11, LOW);
					}

					for(int n = 0; n < 100; n++) {
						digitalWrite(8, HIGH);
						delay(1);
						digitalWrite(8, LOW);
						digitalWrite(10, HIGH);
						delay(1);
						digitalWrite(10, LOW);
						digitalWrite(12, HIGH);
						delay(1);
						digitalWrite(12, LOW);
					}
				}
			}

			void frown()
			{
				for(int i = 0; i < 25; i++) {
					for(int n = 8; n <= 12; n++) {
						digitalWrite(n, HIGH);
						delay(1);
						digitalWrite(n, LOW);
					}
				}

				for(int i = 0; i < 25; i++) {
					digitalWrite(10, HIGH);
					delay(1);
					digitalWrite(10, LOW);
					digitalWrite(9, HIGH);
					delay(1);
					digitalWrite(9, LOW);
					digitalWrite(11, HIGH);
					delay(1);
					digitalWrite(11, LOW);
				}

				digitalWrite(10, HIGH);
				delay(75);
				digitalWrite(10, LOW);

				delay(75);
			}

			void newLevel()
			{
				delay(50);
				for(int n = 0; n < 25; n++) {
					for(int i = 8; i <= 12; i++) {
						digitalWrite(i, HIGH);
						delay(1);
						digitalWrite(i, LOW);
					}
				}
			}

};


class MemoryledConnector: public HardwareConnector {
public:
	CustomHandler *customHandler;
	MemoryledConnector(Memoryled* statemachine);

	inline ~MemoryledConnector();

	/*
	 * Initialize the hardware.
	 */
	void init();

	/*
	 * Raise state machine events before processing them in the state machine's runCycle().
	 */
	void raiseEvents();

	/*
	 * Update the hardware depending on the state machine's state.
	 */
	void syncState();

	/*
	 * Optimize power consumption by turning off modules that are not needed.
	 * Return one of the following sleep states:
	 * SLEEP_MODE_IDLE, SLEEP_MODE_ADC, SLEEP_MODE_PWR_DOWN, SLEEP_MODE_PWR_SAVE,
	 * SLEEP_MODE_STANDBY, SLEEP_MODE_EXT_STANDBY
	 * The returned sleep mode is just a recommendation, the actual timer implementation
	 * may not support the given sleep mode.
	 */
	uint8_t prepareSleepMode();
	
private:
	Memoryled* statemachine;
};
	
MemoryledConnector::~MemoryledConnector() {
}

#endif /* MEMORYLEDCONNECTOR_H */
